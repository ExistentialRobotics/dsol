diff -Naur -x '.*' ../dsol/cmake/FindTBB.cmake dsol/cmake/FindTBB.cmake
--- ../dsol/cmake/FindTBB.cmake	1969-12-31 16:00:00.000000000 -0800
+++ dsol/cmake/FindTBB.cmake	2022-07-27 12:41:14.592113689 -0700
@@ -0,0 +1,317 @@
+# Obtained from Justus Calvin:
+# https://github.com/justusc/FindTBB/blob/25ecdea817b3af4a26d74ddcd439642dbd706acb/FindTBB.cmake
+#
+# With the following modifications:
+# * Move the "tbb" imported library target into a namespace as "TBB::tbb" to
+#   conform to modern CMake conventions.
+# * Append "lib" as a library path suffix on all platforms.
+#
+# The MIT License (MIT)
+#
+# Copyright (c) 2015 Justus Calvin
+# 
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to deal
+# in the Software without restriction, including without limitation the rights
+# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+# copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+# 
+# The above copyright notice and this permission notice shall be included in all
+# copies or substantial portions of the Software.
+# 
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+# SOFTWARE.
+
+#
+# FindTBB
+# -------
+#
+# Find TBB include directories and libraries.
+#
+# Usage:
+#
+#  find_package(TBB [major[.minor]] [EXACT]
+#               [QUIET] [REQUIRED]
+#               [[COMPONENTS] [components...]]
+#               [OPTIONAL_COMPONENTS components...]) 
+#
+# where the allowed components are tbbmalloc and tbb_preview. Users may modify 
+# the behavior of this module with the following variables:
+#
+# * TBB_ROOT_DIR          - The base directory the of TBB installation.
+# * TBB_INCLUDE_DIR       - The directory that contains the TBB headers files.
+# * TBB_LIBRARY           - The directory that contains the TBB library files.
+# * TBB_<library>_LIBRARY - The path of the TBB the corresponding TBB library. 
+#                           These libraries, if specified, override the 
+#                           corresponding library search results, where <library>
+#                           may be tbb, tbb_debug, tbbmalloc, tbbmalloc_debug,
+#                           tbb_preview, or tbb_preview_debug.
+# * TBB_USE_DEBUG_BUILD   - The debug version of tbb libraries, if present, will
+#                           be used instead of the release version.
+#
+# Users may modify the behavior of this module with the following environment
+# variables:
+#
+# * TBB_INSTALL_DIR 
+# * TBBROOT
+# * LIBRARY_PATH
+#
+# This module will set the following variables:
+#
+# * TBB_FOUND             - Set to false, or undefined, if we haven’t found, or
+#                           don’t want to use TBB.
+# * TBB_<component>_FOUND - If False, optional <component> part of TBB sytem is
+#                           not available.
+# * TBB_VERSION           - The full version string
+# * TBB_VERSION_MAJOR     - The major version
+# * TBB_VERSION_MINOR     - The minor version
+# * TBB_INTERFACE_VERSION - The interface version number defined in 
+#                           tbb/tbb_stddef.h.
+# * TBB_<library>_LIBRARY_RELEASE - The path of the TBB release version of 
+#                           <library>, where <library> may be tbb, tbb_debug,
+#                           tbbmalloc, tbbmalloc_debug, tbb_preview, or 
+#                           tbb_preview_debug.
+# * TBB_<library>_LIBRARY_DEGUG - The path of the TBB release version of 
+#                           <library>, where <library> may be tbb, tbb_debug,
+#                           tbbmalloc, tbbmalloc_debug, tbb_preview, or 
+#                           tbb_preview_debug.
+#
+# The following varibles should be used to build and link with TBB:
+#
+# * TBB_INCLUDE_DIRS        - The include directory for TBB.
+# * TBB_LIBRARIES           - The libraries to link against to use TBB.
+# * TBB_LIBRARIES_RELEASE   - The release libraries to link against to use TBB.
+# * TBB_LIBRARIES_DEBUG     - The debug libraries to link against to use TBB.
+# * TBB_DEFINITIONS         - Definitions to use when compiling code that uses
+#                             TBB.
+# * TBB_DEFINITIONS_RELEASE - Definitions to use when compiling release code that
+#                             uses TBB.
+# * TBB_DEFINITIONS_DEBUG   - Definitions to use when compiling debug code that
+#                             uses TBB.
+#
+# This module will also create the "TBB::tbb" target that may be used when
+# building executables and libraries.
+
+include(FindPackageHandleStandardArgs)
+
+if(NOT TBB_FOUND)
+
+  ##################################
+  # Check the build type
+  ##################################
+  
+  if(NOT DEFINED TBB_USE_DEBUG_BUILD)
+    if(CMAKE_BUILD_TYPE MATCHES "(Debug|DEBUG|debug|RelWithDebInfo|RELWITHDEBINFO|relwithdebinfo)")
+      set(TBB_BUILD_TYPE DEBUG)
+    else()
+      set(TBB_BUILD_TYPE RELEASE)
+    endif()
+  elseif(TBB_USE_DEBUG_BUILD)
+    set(TBB_BUILD_TYPE DEBUG)
+  else()
+    set(TBB_BUILD_TYPE RELEASE)
+  endif()
+  
+  ##################################
+  # Set the TBB search directories
+  ##################################
+  
+  # Define search paths based on user input and environment variables
+  set(TBB_SEARCH_DIR ${TBB_ROOT_DIR} $ENV{TBB_INSTALL_DIR} $ENV{TBBROOT})
+  
+  # Define the search directories based on the current platform
+  if(CMAKE_SYSTEM_NAME STREQUAL "Windows")
+    set(TBB_DEFAULT_SEARCH_DIR "C:/Program Files/Intel/TBB"
+                               "C:/Program Files (x86)/Intel/TBB")
+
+    # Set the target architecture
+    if(CMAKE_SIZEOF_VOID_P EQUAL 8)
+      set(TBB_ARCHITECTURE "intel64")
+    else()
+      set(TBB_ARCHITECTURE "ia32")
+    endif()
+
+    # Set the TBB search library path search suffix based on the version of VC
+    if(WINDOWS_STORE)
+      set(TBB_LIB_PATH_SUFFIX "lib/${TBB_ARCHITECTURE}/vc11_ui")
+    elseif(MSVC14)
+      set(TBB_LIB_PATH_SUFFIX "lib/${TBB_ARCHITECTURE}/vc14")
+    elseif(MSVC12)
+      set(TBB_LIB_PATH_SUFFIX "lib/${TBB_ARCHITECTURE}/vc12")
+    elseif(MSVC11)
+      set(TBB_LIB_PATH_SUFFIX "lib/${TBB_ARCHITECTURE}/vc11")
+    elseif(MSVC10)
+      set(TBB_LIB_PATH_SUFFIX "lib/${TBB_ARCHITECTURE}/vc10")
+    endif()
+
+    # Add the library path search suffix for the VC independent version of TBB
+    list(APPEND TBB_LIB_PATH_SUFFIX "lib/${TBB_ARCHITECTURE}/vc_mt")
+
+  elseif(CMAKE_SYSTEM_NAME STREQUAL "Darwin")
+    # OS X
+    set(TBB_DEFAULT_SEARCH_DIR "/opt/intel/tbb")
+    
+    # TODO: Check to see which C++ library is being used by the compiler.
+    if(NOT ${CMAKE_SYSTEM_VERSION} VERSION_LESS 13.0)
+      # The default C++ library on OS X 10.9 and later is libc++
+      set(TBB_LIB_PATH_SUFFIX "lib/libc++")
+    endif()
+  elseif(CMAKE_SYSTEM_NAME STREQUAL "Linux")
+    # Linux
+    set(TBB_DEFAULT_SEARCH_DIR "/opt/intel/tbb")
+    
+    # TODO: Check compiler version to see the suffix should be <arch>/gcc4.1 or
+    #       <arch>/gcc4.1. For now, assume that the compiler is more recent than
+    #       gcc 4.4.x or later.
+    if(CMAKE_SYSTEM_PROCESSOR STREQUAL "x86_64")
+      set(TBB_LIB_PATH_SUFFIX "lib/intel64/gcc4.4")
+    elseif(CMAKE_SYSTEM_PROCESSOR MATCHES "^i.86$")
+      set(TBB_LIB_PATH_SUFFIX "lib/ia32/gcc4.4")
+    endif()
+  endif()
+  
+  # The above TBB_LIB_PATH_SUFFIX is based on where Intel puts the libraries
+  # in the package of prebuilt libraries it distributes. However, users may
+  # install these shared libraries into the more conventional "lib" directory
+  # (especially when building from source), so we add that as an additional
+  # location to search.
+  list(APPEND TBB_LIB_PATH_SUFFIX "lib")
+
+  ##################################
+  # Find the TBB include dir
+  ##################################
+  
+  find_path(TBB_INCLUDE_DIRS tbb/tbb.h
+      HINTS ${TBB_INCLUDE_DIR} ${TBB_SEARCH_DIR}
+      PATHS ${TBB_DEFAULT_SEARCH_DIR}
+      PATH_SUFFIXES include)
+
+  ##################################
+  # Set version strings
+  ##################################
+
+  if(TBB_INCLUDE_DIRS)
+    file(READ "${TBB_INCLUDE_DIRS}/tbb/tbb_stddef.h" _tbb_version_file)
+    string(REGEX REPLACE ".*#define TBB_VERSION_MAJOR ([0-9]+).*" "\\1"
+        TBB_VERSION_MAJOR "${_tbb_version_file}")
+    string(REGEX REPLACE ".*#define TBB_VERSION_MINOR ([0-9]+).*" "\\1"
+        TBB_VERSION_MINOR "${_tbb_version_file}")
+    string(REGEX REPLACE ".*#define TBB_INTERFACE_VERSION ([0-9]+).*" "\\1"
+        TBB_INTERFACE_VERSION "${_tbb_version_file}")
+    set(TBB_VERSION "${TBB_VERSION_MAJOR}.${TBB_VERSION_MINOR}")
+  endif()
+
+  ##################################
+  # Find TBB components
+  ##################################
+
+  if(TBB_VERSION VERSION_LESS 4.3)
+    set(TBB_SEARCH_COMPOMPONENTS tbb_preview tbbmalloc tbb)
+  else()
+    set(TBB_SEARCH_COMPOMPONENTS tbb_preview tbbmalloc_proxy tbbmalloc tbb)
+  endif()
+
+  # Find each component
+  foreach(_comp ${TBB_SEARCH_COMPOMPONENTS})
+    if(";${TBB_FIND_COMPONENTS};tbb;" MATCHES ";${_comp};")
+
+      # Search for the libraries
+      find_library(TBB_${_comp}_LIBRARY_RELEASE ${_comp}
+          HINTS ${TBB_LIBRARY} ${TBB_SEARCH_DIR}
+          PATHS ${TBB_DEFAULT_SEARCH_DIR} ENV LIBRARY_PATH
+          PATH_SUFFIXES ${TBB_LIB_PATH_SUFFIX})
+
+      find_library(TBB_${_comp}_LIBRARY_DEBUG ${_comp}_debug
+          HINTS ${TBB_LIBRARY} ${TBB_SEARCH_DIR}
+          PATHS ${TBB_DEFAULT_SEARCH_DIR} ENV LIBRARY_PATH
+          PATH_SUFFIXES ${TBB_LIB_PATH_SUFFIX})
+
+      if(TBB_${_comp}_LIBRARY_DEBUG)
+        list(APPEND TBB_LIBRARIES_DEBUG "${TBB_${_comp}_LIBRARY_DEBUG}")
+      endif()
+      if(TBB_${_comp}_LIBRARY_RELEASE)
+        list(APPEND TBB_LIBRARIES_RELEASE "${TBB_${_comp}_LIBRARY_RELEASE}")
+      endif()
+      if(TBB_${_comp}_LIBRARY_${TBB_BUILD_TYPE} AND NOT TBB_${_comp}_LIBRARY)
+        set(TBB_${_comp}_LIBRARY "${TBB_${_comp}_LIBRARY_${TBB_BUILD_TYPE}}")
+      endif()
+
+      if(TBB_${_comp}_LIBRARY AND EXISTS "${TBB_${_comp}_LIBRARY}")
+        set(TBB_${_comp}_FOUND TRUE)
+      else()
+        set(TBB_${_comp}_FOUND FALSE)
+      endif()
+
+      # Mark internal variables as advanced
+      mark_as_advanced(TBB_${_comp}_LIBRARY_RELEASE)
+      mark_as_advanced(TBB_${_comp}_LIBRARY_DEBUG)
+      mark_as_advanced(TBB_${_comp}_LIBRARY)
+
+    endif()
+  endforeach()
+
+  ##################################
+  # Set compile flags and libraries
+  ##################################
+
+  set(TBB_DEFINITIONS_RELEASE "")
+  set(TBB_DEFINITIONS_DEBUG "-DTBB_USE_DEBUG=1")
+    
+  if(TBB_LIBRARIES_${TBB_BUILD_TYPE})
+    set(TBB_DEFINITIONS "${TBB_DEFINITIONS_${TBB_BUILD_TYPE}}")
+    set(TBB_LIBRARIES "${TBB_LIBRARIES_${TBB_BUILD_TYPE}}")
+  elseif(TBB_LIBRARIES_RELEASE)
+    set(TBB_DEFINITIONS "${TBB_DEFINITIONS_RELEASE}")
+    set(TBB_LIBRARIES "${TBB_LIBRARIES_RELEASE}")
+  elseif(TBB_LIBRARIES_DEBUG)
+    set(TBB_DEFINITIONS "${TBB_DEFINITIONS_DEBUG}")
+    set(TBB_LIBRARIES "${TBB_LIBRARIES_DEBUG}")
+  endif()
+
+  find_package_handle_standard_args(TBB 
+      REQUIRED_VARS TBB_INCLUDE_DIRS TBB_LIBRARIES
+      HANDLE_COMPONENTS
+      VERSION_VAR TBB_VERSION)
+
+  ##################################
+  # Create targets
+  ##################################
+
+  if(NOT CMAKE_VERSION VERSION_LESS 3.0 AND TBB_FOUND)
+    add_library(TBB::tbb SHARED IMPORTED)
+    set_target_properties(TBB::tbb PROPERTIES
+          INTERFACE_INCLUDE_DIRECTORIES  ${TBB_INCLUDE_DIRS}
+          IMPORTED_LOCATION              ${TBB_LIBRARIES})
+    if(TBB_LIBRARIES_RELEASE AND TBB_LIBRARIES_DEBUG)
+      set_target_properties(TBB::tbb PROPERTIES
+          INTERFACE_COMPILE_DEFINITIONS "$<$<OR:$<CONFIG:Debug>,$<CONFIG:RelWithDebInfo>>:TBB_USE_DEBUG=1>"
+          IMPORTED_LOCATION_DEBUG          ${TBB_LIBRARIES_DEBUG}
+          IMPORTED_LOCATION_RELWITHDEBINFO ${TBB_LIBRARIES_DEBUG}
+          IMPORTED_LOCATION_RELEASE        ${TBB_LIBRARIES_RELEASE}
+          IMPORTED_LOCATION_MINSIZEREL     ${TBB_LIBRARIES_RELEASE}
+          )
+    elseif(TBB_LIBRARIES_RELEASE)
+      set_target_properties(TBB::tbb PROPERTIES IMPORTED_LOCATION ${TBB_LIBRARIES_RELEASE})
+    else()
+      set_target_properties(TBB::tbb PROPERTIES
+          INTERFACE_COMPILE_DEFINITIONS "${TBB_DEFINITIONS_DEBUG}"
+          IMPORTED_LOCATION              ${TBB_LIBRARIES_DEBUG}
+          )
+    endif()
+  endif()
+
+  mark_as_advanced(TBB_INCLUDE_DIRS TBB_LIBRARIES)
+
+  unset(TBB_ARCHITECTURE)
+  unset(TBB_BUILD_TYPE)
+  unset(TBB_LIB_PATH_SUFFIX)
+  unset(TBB_DEFAULT_SEARCH_DIR)
+
+endif()
+
diff -Naur -x '.*' ../dsol/CMakeLists.txt dsol/CMakeLists.txt
--- ../dsol/CMakeLists.txt	2022-07-27 13:24:57.163558878 -0700
+++ dsol/CMakeLists.txt	2022-07-27 12:41:14.588113721 -0700
@@ -31,15 +31,15 @@
              visualization_msgs)
 
 find_package(TBB REQUIRED)
-find_package(fmt REQUIRED)
-find_package(glog REQUIRED)
-find_package(absl REQUIRED)
+#find_package(fmt REQUIRED)
+#find_package(glog REQUIRED)
+#find_package(absl REQUIRED)
 find_package(Boost REQUIRED) # circular buffer
 
 find_package(Eigen3 REQUIRED)
 find_package(Sophus REQUIRED)
 find_package(OpenCV REQUIRED)
-find_package(xtensor) # reading npy
+#find_package(xtensor) # reading npy
 
 find_package(GTest REQUIRED)
 find_package(benchmark REQUIRED)
@@ -54,4 +54,7 @@
 endif()
 
 enable_testing()
+add_subdirectory(abseil-cpp)
+add_subdirectory(fmt)
+add_subdirectory(glog)
 add_subdirectory(sv)
diff -Naur -x '.*' ../dsol/launch/dsol_ros.launch dsol/launch/dsol_ros.launch
--- ../dsol/launch/dsol_ros.launch	1969-12-31 16:00:00.000000000 -0800
+++ dsol/launch/dsol_ros.launch	2022-07-27 12:41:14.596113656 -0700
@@ -0,0 +1,70 @@
+<launch>
+
+  <!-- Launch realsense camera -->  
+    <include file="$(find realsense2_camera)/launch/rs_camera.launch">
+      <arg name="enable_infra1"       value="true" />
+      <arg name="enable_infra2"       value="true" />
+      <arg name="infra_fps"           value="60"   />
+    </include>
+  
+  <!-- Launch teleop -->
+  <arg name="racecar_version" default="racecar-v2" />
+  <include file="$(find racecar)/launch/includes/$(arg racecar_version)-teleop.launch.xml">
+    <arg name="racecar_version" value="$(arg racecar_version)" />
+  </include>
+
+
+  <!-- Launch DSOL -->  
+    <arg name="debug" default="false"/>
+    <env if="$(arg debug)" name="ROSCONSOLE_CONFIG_FILE" value="$(find dsol)/launch/debug.conf"/>
+
+    <arg name="start" default="0"/>
+    <arg name="end" default="0"/>
+    <arg name="reverse" default="false"/>
+
+    <arg name="tbb" default="1"/>
+    <arg name="log" default="5"/>
+    <arg name="vis" default="false"/>
+    <arg name="freq" default="10"/>
+    <arg name="save" default=""/>
+    <arg name="wait_ms" default="8"/>
+
+    <!-- <arg name="data" default="d455"/> -->
+
+    <!-- <arg name="data_dir" default="/home/chao/Workspace/dataset/vkitti/Scene01/clone"/> -->
+    <!-- <arg name="data_dir" default="/home/chao/Workspace/dataset/kitti/dataset/sequences/00"/> -->
+    <!-- <arg name="data_dir" default="/media/psf/robo/catkin_ws/src/dsol/tartan_air/P001"/> -->
+
+    <arg name="data_max_depth" default="100.0"/>
+    <arg name="cloud_max_depth" default="50.0"/>
+    <arg name="motion_alpha" default="0.5"/>
+
+    <node pkg="dsol" type="sv_dsol_node_data" name="dsol_data" output="screen">
+        <rosparam command="load" file="$(find dsol)/config/dsol.yaml"/>
+        <!-- <rosparam command="load" file="$(find dsol)/config/dsol_$(arg data).yaml"/> -->
+
+	<param name="buffer" type="int" value="1000" />
+	<param name="left_img" type="string" value="/camera/infra1/image_rect_raw" />
+	<param name="right_img" type="string" value="/camera/infra2/image_rect_raw" />
+        
+	<param name="tbb" type="int" value="$(arg tbb)"/>
+        <param name="log" type="int" value="$(arg log)"/>
+        <param name="vis" type="bool" value="$(arg vis)"/>
+        <param name="freq" type="double" value="$(arg freq)"/>
+        <param name="save" type="string" value="$(arg save)"/>
+        <param name="wait_ms" type="int" value="$(arg wait_ms)"/>
+
+        <!-- <param name="data_dir" type="str" value="$(arg data_dir)"/> -->
+        <param name="data_max_depth" type="double" value="$(arg data_max_depth)"/>
+        <param name="cloud_max_depth" type="double" value="$(arg cloud_max_depth)"/>
+        <param name="motion_alpha" type="double" value="$(arg motion_alpha)"/>
+
+        <param name="start" type="int" value="$(arg start)"/>
+        <param name="end" type="int" value="$(arg end)"/>
+        <param name="reverse" type="bool" value="$(arg reverse)"/>
+    </node>
+
+     <!-- <node type="rviz" name="rviz" pkg="rviz" args="-d $(find dsol)/launch/dsol.rviz" /> -->
+
+</launch>
+
diff -Naur -x '.*' ../dsol/py/extract_image.py dsol/py/extract_image.py
--- ../dsol/py/extract_image.py	2022-07-27 13:24:57.163558878 -0700
+++ dsol/py/extract_image.py	2022-07-27 12:41:14.596113656 -0700
@@ -1,13 +1,13 @@
 import cv2
 from pathlib import Path
-from tqdm import tqdm
+#from tqdm import tqdm
 
 import rosbag
 from sensor_msgs.msg import Image
 from cv_bridge import CvBridge
 
 if __name__ == '__main__':
-    bag_file = "/home/chao/Dropbox/Data/d455/20220307_172336.bag"
+    bag_file = "/home/nvidia/dsol_ws/datasets/realsense/20220307_171655.bag"
     bag_name = "indoor_1"
     bag = rosbag.Bag(bag_file, "r")
     bridge = CvBridge()
@@ -17,13 +17,13 @@
         "/device_0/sensor_0/Infrared_2/image/data"
     ]
 
-    data_dir = Path("/home/chao/Documents/realsense") / bag_name
+    data_dir = Path("/home/nvidia/dsol_ws/datasets/realsense") / bag_name
     left_dir = data_dir / "infra1"
     right_dir = data_dir / "infra2"
     left_dir.mkdir(parents=True, exist_ok=True)
     right_dir.mkdir(parents=True, exist_ok=True)
 
-    for topic, msg, t in tqdm(bag.read_messages(topics=topics)):
+    for topic, msg, t in bag.read_messages(topics=topics):
         count = t.to_nsec() // 1000000
 
         cv_img = bridge.imgmsg_to_cv2(msg, desired_encoding="passthrough")
@@ -31,4 +31,4 @@
             cv2.imwrite(str(left_dir / f"image{count:08d}.png"), cv_img)
         elif topic == topics[1]:
             cv2.imwrite(str(right_dir / f"image{count:08d}.png"), cv_img)
-    bag.close()
\ No newline at end of file
+    bag.close()
diff -Naur -x '.*' ../dsol/README.md dsol/README.md
--- ../dsol/README.md	2022-07-27 13:24:57.163558878 -0700
+++ dsol/README.md	2022-07-27 12:41:14.588113721 -0700
@@ -49,10 +49,9 @@
 roslaunch dsol dsol_data.launch tbb:=1 log:=5
 ```
 
-## Dependencies and Install instructions
+## Dependencies
 
-See CMakeLists.txt for dependencies. You may also check our [Github Action build
-file](https://github.com/versatran01/dsol/blob/main/.github/workflows/build.yaml) for instructions on how to build DSOL in Ubuntu 20.04 with ROS Noetic.
+See CMakeLists.txt for dependencies.
 
 ## Disclaimer
 
diff -Naur -x '.*' ../dsol/sv/dsol/CMakeLists.txt dsol/sv/dsol/CMakeLists.txt
--- ../dsol/sv/dsol/CMakeLists.txt	2022-07-27 13:24:57.167558803 -0700
+++ dsol/sv/dsol/CMakeLists.txt	2022-07-27 12:41:14.600113624 -0700
@@ -216,6 +216,6 @@
 
   cc_binary(
     NAME dsol_node_data
-    SRCS "node_data.cpp"
+    SRCS "node_ros.cpp"
     DEPS sv_dsol_extra sv_util_dataset sv_dsol_node_util)
 endif()
diff -Naur -x '.*' ../dsol/sv/dsol/node_ros.cpp dsol/sv/dsol/node_ros.cpp
--- ../dsol/sv/dsol/node_ros.cpp	1969-12-31 16:00:00.000000000 -0800
+++ dsol/sv/dsol/node_ros.cpp	2022-07-27 12:41:14.616113494 -0700
@@ -0,0 +1,302 @@
+#include <geometry_msgs/PoseArray.h>
+#include <geometry_msgs/TransformStamped.h>
+#include <ros/ros.h>
+#include <rosgraph_msgs/Clock.h>
+#include <tf2_ros/transform_broadcaster.h>
+#include "sv/dsol/extra.h"
+#include "sv/dsol/node_util.h"
+#include "sv/ros1/msg_conv.h"
+#include "sv/util/dataset.h"
+#include "sv/util/logging.h"
+#include "sv/util/ocv.h"
+//#include <cv.h>
+#include "sensor_msgs/Image.h"
+#include <cv_bridge/cv_bridge.h>
+#include <message_filters/subscriber.h>
+#include <message_filters/time_synchronizer.h>
+#include <message_filters/sync_policies/approximate_time.h>
+
+namespace sv::dsol {
+
+using SE3d = Sophus::SE3d;
+namespace gm = geometry_msgs;
+namespace sm = sensor_msgs;
+namespace vm = visualization_msgs;
+
+struct NodeData {
+  explicit NodeData(const ros::NodeHandle& pnh);
+
+  void InitOdom();
+  void InitRosIO();
+
+  void PublishOdom(const std_msgs::Header& header, const Sophus::SE3d& Twc);
+  void PublishCloud(const std_msgs::Header& header) const;
+  void SendTransform(const gm::PoseStamped& pose_msg,
+                     const std::string& child_frame);
+  void ImageCallback(const sensor_msgs::ImageConstPtr& msgLeft,
+                     const sensor_msgs::ImageConstPtr& msgRight);
+  void DoubleImageCallback(const sensor_msgs::ImageConstPtr& image1, const sensor_msgs::ImageConstPtr& image2);
+  void Run(cv_bridge::CvImageConstPtr cv_ptrLeft,
+           cv_bridge::CvImageConstPtr cv_ptrRight, const ros::Time timestamp);
+
+  double data_max_depth_{0};
+  double cloud_max_depth_{100};
+  std::string left_img_;
+  std::string right_img_;
+  int buffer_;
+
+//   Dataset dataset_;
+  MotionModel motion_;
+  TumFormatWriter writer_;
+  DirectOdometry odom_;
+
+  KeyControl ctrl_;
+  std::string frame_{"fixed"};
+  tf2_ros::TransformBroadcaster tfbr_;
+
+  ros::NodeHandle pnh_;
+  ros::Publisher clock_pub_;
+  ros::Publisher pose_array_pub_;
+  ros::Publisher align_marker_pub_;
+  PosePathPublisher kf_pub_;
+  PosePathPublisher odom_pub_;
+
+  ros::Publisher points_pub_;
+
+  ros::Time current_frame_time_;
+
+
+  typedef message_filters::sync_policies::ApproximateTime<sensor_msgs::Image, sensor_msgs::Image> sync_pol;
+  message_filters::Subscriber<sensor_msgs::Image> *left_sub_;
+  message_filters::Subscriber<sensor_msgs::Image> *right_sub_;
+  message_filters::Synchronizer<sync_pol> *sync_;
+
+  double prev_time {-1};
+  int flag {0};
+  int cnt {0};
+
+  bool init_tf{false};
+  // The default SE(3) matrix is Identity for Sophus objects
+  SE3d dT_pred;
+  SE3d T_c0_c_gt;
+
+};
+
+NodeData::NodeData(const ros::NodeHandle& pnh) : pnh_{pnh} {
+  InitRosIO();
+  InitOdom();
+  // Wait after key_control
+  const int wait_ms = pnh_.param<int>("wait_ms", 0);
+  ROS_INFO_STREAM("wait_ms: " << wait_ms);
+  ctrl_ = KeyControl(wait_ms);
+
+  const auto save = pnh_.param<std::string>("save", "");
+  writer_ = TumFormatWriter(save);
+  if (!writer_.IsDummy()) {
+    //ROS_WARN_STREAM("Writing results to: " << writer_.filename());
+  }
+
+  const auto alpha = pnh_.param<double>("motion_alpha", 0.5);
+  motion_ = MotionModel(alpha);
+  //ROS_INFO_STREAM("motion_alpha: " << motion_.alpha());
+}
+
+
+void NodeData::ImageCallback(const sensor_msgs::ImageConstPtr& msgLeft, const sensor_msgs::ImageConstPtr& msgRight /*, const sensor_msgs::ImageConstPtr& msgDepth*/) {
+  cv_bridge::CvImageConstPtr cv_ptrLeft;
+  try {
+      cv_ptrLeft = cv_bridge::toCvShare(msgLeft);
+  } catch (cv_bridge::Exception& e) {
+      ROS_ERROR("cv_bridge exception: %s", e.what());
+      return;
+  }
+
+  cv_bridge::CvImageConstPtr cv_ptrRight;
+  try {
+      cv_ptrRight = cv_bridge::toCvShare(msgRight);
+  } catch (cv_bridge::Exception& e) {
+      ROS_ERROR("cv_bridge exception: %s", e.what());
+      return;
+  }
+
+  //ROS_INFO_STREAM("Received 2 images in both cameras");
+  Run(cv_ptrLeft, cv_ptrRight, cv_ptrLeft->header.stamp);
+}  
+
+void SingleImageCallback(const sensor_msgs::ImageConstPtr& image){
+  //ROS_INFO_STREAM("Received an image in left camera");
+  return;
+}
+void NodeData::DoubleImageCallback(const sensor_msgs::ImageConstPtr& image1, const sensor_msgs::ImageConstPtr& image2){
+  //ROS_INFO_STREAM("Received 2 images in both cameras");
+  return;
+}
+
+void NodeData::InitRosIO() {
+  clock_pub_ = pnh_.advertise<rosgraph_msgs::Clock>("/clock", 1);
+
+  kf_pub_ = PosePathPublisher(pnh_, "kf", frame_);
+  odom_pub_ = PosePathPublisher(pnh_, "odom", frame_);
+  points_pub_ = pnh_.advertise<sm::PointCloud2>("points", 1);
+  pose_array_pub_ = pnh_.advertise<gm::PoseArray>("poses", 1);
+  align_marker_pub_ = pnh_.advertise<vm::Marker>("align_graph", 1);
+
+  pnh_.getParam("left_img", left_img_);
+  pnh_.getParam("right_img", right_img_);
+  pnh_.getParam("buffer", buffer_);
+
+  left_sub_ = new message_filters::Subscriber<sensor_msgs::Image> (pnh_, left_img_, buffer_);
+  right_sub_ = new message_filters::Subscriber<sensor_msgs::Image> (pnh_, right_img_, buffer_);
+  
+  //left_sub_ = new message_filters::Subscriber<sensor_msgs::Image> (pnh_, "/device_0/sensor_0/Infrared_1/image/data", 1);
+  //right_sub_ = new message_filters::Subscriber<sensor_msgs::Image> (pnh_, "/device_0/sensor_0/Infrared_2/image/data", 1);
+  
+  //left_sub_->registerCallback(SingleImageCallback);
+
+  // depth_sub_ = new message_filters::Subscriber<sensor_msgs::Image> (pnh_, "depth/image_rect_raw", 1);
+  
+  sync_ = new message_filters::Synchronizer<sync_pol> (sync_pol(10), *left_sub_, *right_sub_);
+  // sync_ = new message_filters::Synchronizer<sync_pol> (sync_pol(10), *left_sub_, *right_sub_, *depth_sub);
+
+  //sync_->registerCallback(boost::bind(&NodeData::DoubleImageCallback, this, _1, _2));
+  sync_->registerCallback(boost::bind(&NodeData::ImageCallback, this, _1, _2));
+   //sync_->registerCallback(boost::bind(&NodeData::ImageCallback, this, _1, _2, _3));
+
+  // pnh_.getParam("freq", freq_);
+  pnh_.getParam("data_max_depth", data_max_depth_);
+  pnh_.getParam("cloud_max_depth", cloud_max_depth_);
+
+}
+
+void NodeData::InitOdom() {
+  {
+    auto cfg = ReadOdomCfg({pnh_, "odom"});
+    pnh_.getParam("tbb", cfg.tbb);
+    pnh_.getParam("log", cfg.log);
+    pnh_.getParam("vis", cfg.vis);
+    odom_.Init(cfg);
+  }
+  odom_.selector = PixelSelector(ReadSelectCfg({pnh_, "select"}));
+  odom_.matcher = StereoMatcher(ReadStereoCfg({pnh_, "stereo"}));
+  odom_.aligner = FrameAligner(ReadDirectCfg({pnh_, "align"}));
+  odom_.adjuster = BundleAdjuster(ReadDirectCfg({pnh_, "adjust"}));
+  odom_.cmap = GetColorMap(pnh_.param<std::string>("cm", "jet"));
+
+  //ROS_INFO_STREAM(odom_.Repr());
+}
+
+void NodeData::PublishCloud(const std_msgs::Header& header) const {
+  if (points_pub_.getNumSubscribers() == 0) return;
+
+  static sensor_msgs::PointCloud2 cloud;
+  cloud.header = header;
+  cloud.point_step = 16;
+  cloud.fields = MakePointFieldsXYZI();
+
+  ROS_DEBUG_STREAM(odom_.window.MargKf().status().Repr());
+  Keyframe2Cloud(odom_.window.MargKf(), cloud, cloud_max_depth_);
+  points_pub_.publish(cloud);
+}
+
+void NodeData::SendTransform(const geometry_msgs::PoseStamped& pose_msg,
+                             const std::string& child_frame) {
+  gm::TransformStamped tf_msg;
+  tf_msg.header = pose_msg.header;
+  tf_msg.child_frame_id = child_frame;
+  Ros2Ros(pose_msg.pose, tf_msg.transform);
+  tfbr_.sendTransform(tf_msg);
+}
+
+void NodeData::Run(cv_bridge::CvImageConstPtr cv_ptrLeft, cv_bridge::CvImageConstPtr cv_ptrRight, const ros::Time timestamp) {
+  double dt;
+  double timestamp_sec = timestamp.toSec();
+  //ROS_INFO_STREAM("In the Run callback");
+
+  if(prev_time < 0){
+    motion_.Init(T_c0_c_gt);
+    prev_time = timestamp_sec;
+    dt = 0;
+    flag = 1; //flag is set to 1 only for the first iteration
+  }
+  else{
+    dt = timestamp_sec - prev_time;
+    prev_time = timestamp_sec;
+    dT_pred = motion_.PredictDelta(dt);
+    flag = 0;
+  }
+
+  auto image_l = cv_ptrLeft->image;
+  auto image_r = cv_ptrRight->image;
+
+  // Intrinsic
+  if (!odom_.camera.Ok()){
+  // These are for the ERL Realsense camera
+  //const cv::Mat intrin({1, 5}, {380.4, 312.9, 379.9, 247.2, 0.095});
+
+  // These are for the Realsense camera from the repo
+  const cv::Mat intrin({1, 5}, {393.4910888671875, 393.4910888671875, 318.6263122558594, 240.12942504882812, 0.095150406});
+
+  const auto camera = Camera::FromMat({image_l.cols, image_l.rows}, intrin);
+  odom_.SetCamera(camera);
+  //ROS_INFO_STREAM(camera);
+  }
+
+  // Odom
+  //ROS_INFO_STREAM("Before calling Estimate");
+  const auto status = odom_.Estimate(image_l, image_r, dT_pred);
+  //ROS_INFO_STREAM(status.Repr());
+
+  // Motion model correct if tracking is ok and not first frame
+  if (status.track.ok && flag == 0) {
+    motion_.Correct(status.Twc(), dt);
+  } else {
+    ROS_WARN_STREAM("Tracking failed (or 1st frame), slow motion model");
+    motion_.Scale(0.5);
+  }
+
+  // Write to output
+  writer_.Write(cnt++, status.Twc());
+
+  // ROS_DEBUG_STREAM("trans gt:   " << T_c0_c_gt.translation().transpose());
+  //ROS_DEBUG_STREAM("trans odom: " << status.Twc().translation().transpose());
+  //ROS_DEBUG_STREAM("trans ba:   " << odom_.window.CurrKf().Twc().translation().transpose());
+  //ROS_DEBUG_STREAM("aff_l: " << odom_.frame.state().affine_l.ab.transpose());
+  //ROS_DEBUG_STREAM("aff_r: " << odom_.frame.state().affine_r.ab.transpose());
+
+  // publish stuff
+  std_msgs::Header header;
+  header.frame_id = frame_;
+  header.stamp = timestamp;
+
+  PublishOdom(header, status.Twc());
+  //ROS_INFO_STREAM("Odometry published and towards the end");
+
+  if (status.map.remove_kf) {
+    PublishCloud(header);
+  }
+  return;
+}
+
+void NodeData::PublishOdom(const std_msgs::Header& header,
+                           const Sophus::SE3d& Twc) {
+  const auto odom_pose_msg = odom_pub_.Publish(header.stamp, Twc);
+  SendTransform(odom_pose_msg, "camera");
+
+  const auto poses = odom_.window.GetAllPoses();
+  gm::PoseArray pose_array_msg;
+  pose_array_msg.header = header;
+  pose_array_msg.poses.resize(poses.size());
+  for (size_t i = 0; i < poses.size(); ++i) {
+    Sophus2Ros(poses.at(i), pose_array_msg.poses.at(i));
+  }
+  pose_array_pub_.publish(pose_array_msg);
+}
+
+} //namespace closure
+
+int main(int argc, char** argv) {
+  ros::init(argc, argv, "dsol_data");
+  sv::dsol::NodeData node{ros::NodeHandle{"~"}};
+  ros::spin();
+  return 0;
+}
diff -Naur -x '.*' ../dsol/sv/util/dataset.cpp dsol/sv/util/dataset.cpp
--- ../dsol/sv/util/dataset.cpp	2022-07-27 13:24:57.179558580 -0700
+++ dsol/sv/util/dataset.cpp	2022-07-27 12:41:14.624113429 -0700
@@ -13,16 +13,16 @@
 #include <istream>
 #include <opencv2/imgcodecs.hpp>  // imread
 #include <opencv2/imgproc.hpp>    // threashold
-
+/*
 #ifndef XTENSOR_FOUND
 #define XTENSOR_FOUND 0
 #endif
-
+*/
 // Conditionallly include xtensor if package found
-#if XTENSOR_FOUND
+//#if XTENSOR_FOUND
 #include <xtensor/xarray.hpp>
 #include <xtensor/xnpy.hpp>
-#endif
+//#endif
 
 namespace sv {
 
@@ -520,7 +520,6 @@
   }
 
   if (dtype == DataType::kDepth) {
-#if XTENSOR_FOUND
     const auto& files = files_.at(DataType::kDepth);
     if (ind >= files.size()) return {};
     const auto raw = xt::load_npy<float>(files.at(ind));
@@ -536,10 +535,6 @@
       }
     }
     return depth;
-#else
-    LOG(WARNING) << "xtensor not found, unable to read npy, return empty depth";
-    return {};
-#endif
   }
 
   if (dtype == DataType::kIntrin) {
diff -Naur -x '.*' ../dsol/sv/util/logging.h dsol/sv/util/logging.h
--- ../dsol/sv/util/logging.h	2022-07-27 13:24:57.179558580 -0700
+++ dsol/sv/util/logging.h	2022-07-27 12:41:14.628113397 -0700
@@ -3,7 +3,7 @@
 #include <fmt/color.h>
 #include <fmt/core.h>
 #include <glog/logging.h>
-
+#include <fmt/ostream.h>
 namespace sv {
 
 struct LogColor {
diff -Naur -x '.*' ../dsol/sv/util/summary.cpp dsol/sv/util/summary.cpp
--- ../dsol/sv/util/summary.cpp	2022-07-27 13:24:57.179558580 -0700
+++ dsol/sv/util/summary.cpp	2022-07-27 12:41:14.632113365 -0700
@@ -1,7 +1,6 @@
 #include "sv/util/summary.h"
 
 #include <fmt/ostream.h>
-
 #include "sv/util/logging.h"
 
 namespace sv {
diff -Naur -x '.*' ../dsol/sv/util/summary.h dsol/sv/util/summary.h
--- ../dsol/sv/util/summary.h	2022-07-27 13:24:57.179558580 -0700
+++ dsol/sv/util/summary.h	2022-07-27 12:41:14.632113365 -0700
@@ -5,7 +5,7 @@
 
 #include <shared_mutex>
 #include <string_view>
-
+#include <mutex>
 #include "sv/util/stats.h"
 #include "sv/util/timer.h"
 
